package jsontogo

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"reflect"
	"regexp"
	"strings"

	"text/template"
)

type TemplateData struct {
	Typename string
	JsonMap  map[string]interface{}
}

const structTemplate = `{{.Typename}} struct {{"{"}}{{range $index, $element := .JsonMap}}
	{{title $index}} {{getType $element $index}} ` + "`json:\"{{$index}}\"`" + `{{end}}
{{"}"}}`

func jsonToGo(jsonString []byte, typename string) ([]byte, error) {
	//Edit JSON string before unmarshal and change all numeric with decimal to 1.1
	//This is to identify float64 vs int before outputting struct
	re := regexp.MustCompile(`[0-9]*\.[0-9]*`)
	jsonString = re.ReplaceAll(jsonString, []byte("1.1"))
	log.Println("jsonToGo replace: ", string(jsonString))

	var tData TemplateData
	if typename == "" {
		typename = "AutoGenerated"
	}

	tData.Typename = typename
	tData.JsonMap = make(map[string]interface{})

	if err := json.Unmarshal(jsonString, &tData.JsonMap); err != nil {
		return jsonString, err
	}
	log.Println(tData.JsonMap)

	structBytes, err := mapToStruct(tData)
	return append([]byte("type "), structBytes...), err
}

func mapToStruct(tData TemplateData) ([]byte, error) {
	funcMap := template.FuncMap{
		"getType": GetType,
		"title":   strings.Title,
		"lower":   strings.ToLower,
	}
	t := template.Must(template.New("structTemplate").Funcs(funcMap).Parse(structTemplate))

	var buf bytes.Buffer
	err := t.Execute(&buf, tData)

	return buf.Bytes(), err
}

func isDecimal(dec string) bool {
	re := regexp.MustCompile(`[0-9]*\.[0-9]*`)
	return re.MatchString(dec)
}

func GetType(v interface{}, key string) string {
	log.Println("GetType", reflect.TypeOf(v))
	typename := fmt.Sprint(reflect.TypeOf(v))
	log.Println("GetType typename ", typename)

	switch typename {
	case "float64", "bool", "string":
		return GetSimpleType(v)
	case "map[string]interface {}":
		if structBytes, err := mapToStruct(TemplateData{Typename: "", JsonMap: v.(map[string]interface{})}); err == nil {
			return string(structBytes)
		} else {
			log.Println("GetType error: ", err)
		}
		return "ERROR"
	case "[]interface {}":
		//log.Printf("GetType first element value type: %v\n", reflect.TypeOf(v.([]interface{})[0]))
		log.Printf("GetType first element value type: %v\n", GetArrayType(v.([]interface{})))
		return GetArrayType(v.([]interface{}))
	default:
		return "interface{}"
	}
}

func GetSimpleType(v interface{}) string {
	typename := fmt.Sprint(reflect.TypeOf(v))
	switch typename {
	case "float64":
		log.Printf("GetType element value: %v\n", v.(float64))
		if isDecimal(fmt.Sprintf("%v", v)) {
			return typename
		}
		return "int"
	case "bool":
		return typename
	case "string":
		return "string"
	}
	return "ERROR"
}

func GetArrayType(v []interface{}) string {
	typesSet := map[string]bool{}
	var typename string
	for _, val := range v {
		typename = fmt.Sprint(reflect.TypeOf(val))
		switch typename {
		case "float64", "bool", "string":
			typename = GetSimpleType(val)
		}
		typesSet[typename] = true
	}

	if len(typesSet) == 2 && typesSet["float64"] && typesSet["int"] {
		return "float64"
	}

	if len(typesSet) == 1 && typesSet["map[string]interface {}"] {
		obj := map[string]interface{}{}
		for _, val := range v {
			for property, value := range val.(map[string]interface{}) {
				obj[property] = value
			}
		}
		//call map to struct for obj variable to get struct definiton
		if structBytes, err := mapToStruct(TemplateData{Typename: "", JsonMap: obj}); err == nil {
			return "[]" + string(structBytes)
		} else {
			log.Println("GetType error: ", err)
		}
	}

	if len(typesSet) == 1 {
		for key := range typesSet {
			return "[]" + key
		}
	}
	return "[]interface{}"
}
